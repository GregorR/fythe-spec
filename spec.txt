Name            AC  Types*      Notes

Objects:
This            0
ThisSet         1
Arg             0
Null            0
Global          0
Version         0               (various platform-specific version info)
New             1   i
Length          1   →i
Member          2   oi
MemberSet       3   oio
Equal           2   →i

Temporaries**:
Temp            1   i           (argument must be a literal)
TempSet         2   io          (first argument must be a literal)

Type detection***:
ValidString     1   →i
ValidFunction   1   →i
ValidInteger    1   →i
ValidFloat      1   →i
ValidTable      2   oi→i        (object and index)

Function/stack:
Call            2   co
Throw           1               (no value)
Catch           0               (2-code****)

Behavioral:
If              0               (2-code****)
While           0               (2-code****)
Seq             variable

Primitives:
Associate       2   po→p
Dissociate      1   p→o

Strings:
SConcat         2   ss→s
SLength         1   s→i
SSlice          3   sii→s
SEqual          2   ss→i
SCode           1   s→c

Array operations:
Array           variable
Concat          2
Slice           3   aii→a

Integers:
IWidth          0   →i
IMul            2   ii→i
IDiv            2   ii→i
IMod            2   ii→i
IAdd            2   ii→i
ISub            2   ii→i
ISl             2   ii→i
ISr             2   ii→i
INot            1   i→i
IOr             2   ii→i
INor            2   ii→i
IXor            2   ii→i
INxor           2   ii→i
IAnd            2   ii→i
INand           2   ii→i
IByte           1   i→s
IEqual          2   ii→i
INe             2   ii→i
ILt             2   ii→i
ILte            2   ii→i
IGt             2   ii→i
IGte            2   ii→i

All the same for floats but prefixed F instead of I, and Sl and Sr are not
provided. Types are the same s/i/f/ except for IEqual and later which return
integers.

Tables:
MGet            3   ois         (table must be in an array index, uninitialized index is fine)
MSet            4   oiso
MList           2   oi
MContains       3   ois→i

Threading (optional, exists if "threads" in (Version)):
Spawn           2   co→t
Join            1   t           (FIXME: what's the return?)
Yield           0               (always returns (Null))
LMutexNew       0   →l
LMutexLock      1   l→l
LMutexTryLock   1   l→i
LMutexUnlock    1   l→l
LMutexDestroy   1   l→o         (alwas returns (Null))
LSemNew         0   →l
LSemPost        1   l→l
LSemWait        1   l→l
LSemDestroy     1   l→o         (alwas returns (Null))
LRWNew          0   →l
LRWRLock        1   l→l
LRWRTryLock     1   l→i
LRWRUnlock      1   l→l
LRWRLock        1   l→l
LRWRTryLock     1   l→i
LRWRUnlock      1   l→l
LRWDestroy      1   l→o         (always returns (Null))
Cas             4   oioo→i      (only compares and swaps the object, not the primitive)
PCas            4   oipp→i      (only compares and swaps the primitive, not the object)

Runtime:
Include         1   s→s         (or a throw for failure)
Parse           1   s
Compile         1   s           (should always return code, but this is a property
                             of the transforms and so not guaranteed)

Grammar:
GAdd            3   soo→s
GRem            1   s→s
GCommit         0               (always returns Null)

Transform:
TAddPhase       2   ss→s
TAddTree        4   ssoo→s
TAddCode        4   ssoc→s
TRem            1   s→s

*
  Types are in the form input→output. Either input or output may be disregarded
  if any sort of object is OK. 'input' is a string of letters, each of which is
  one of:
    o: Heap object (array)
    s: String
    c: Code (function)
    i: Integer
    f: Float
    t: Thread identifier
    l: Lock
    p: Any primitive (s, c, i, f, t or l)

**
  There are infinitely many temporaries, and the job of translating temporaries
  into registers is done by a standardized phase provided by the system.

***
  Type detection returns an integer (0 for false, 1 for true). A positive
  response does NOT indicate that there is actually an associated primitive of
  that type, it only indicates that attempting to use the value as that type
  will not cause the interpreter to crash; this is to make ambiguity in how
  primitives are stored acceptable such that implementations don't need too
  much tagging.

****
  2-code means that as well as taking the arguments specified, the given
  operation takes two arbitrary expressions which will be evaluated or not
  evaluated under some condition.



Values in Fythe are a mandatory object associated with an optional primitive.
Note that associating a primitive with an object will NOT cause all instances
of that object to be associated with that primitive, it's purely a local
change. However, object-primitive pairs move together, and will not become
dissociated unless you explicitly dissociate.

There are two globally-nameable objects in Fythe: Null and Global. Null is a
size-0 object and as such is usable only as a nonce. Global is size-1, with the
first (and only) element being a table.



x86 ABI:
EAX = Returns (as in C)
EBX = General
ECX = General
EDX = Pointer to array of Fythe "registers" and major constants, e.g. (Global), (Version) and
      major implementation functions, plus a pointer to the exception stack.
ESI = Fythe stack pointer
EDI = Fythe base pointer
EBP = C base pointer (as in C)
ESP = C stack pointer (as in C)

Arrangement of the Fythe stack:
EDI should be pushed to the C stack immediately after EBP during the normal
function prologue, and popped before. That is, the function prologue is now:
<
pushl %ebp
pushl %edi
movl %esp, %ebp
movl %esi, %edi
>
The Fythe stack grows UP, unlike the C stack. Each value on the Fythe stack is
two words (as with all Fythe values). The top two words on the Fythe stack when
a Fythe function is called should be the function object called and its
argument. When a Fythe function is finished, these should be on the stack, as
well as its return value. It is free to modify the two slots carrying the
function object and argument, but the rest of the stack should be preserved.
The function epilogue is reverse of the prologue, with the exception that %esi
is not restored (as the stack height at this point MUST be exactly two words
greater than the starting height):
<
movl %ebp, %esp
pop %edi
pop %ebp
ret
>
Note that the C stack is used only for the call stack and preservation of Fythe
base pointers.

Arrangement of EDX array:
0:      Fythe register 0 object
1:      Fythe register 0 primitive
...
30:     Fythe register 15 object
31:     Fythe register 15 primitive
32:     Fythe exception stack pointer
33:     Null
34:     Global
35:     Version

Calls:
Before calling a Fythe function, you must push any Fythe registers that are in
use, as the next function is free to clobber them. Before calling a C function,
you must push all processor registers, but no Fythe registers.



x86_64 ABI:
Same as x86 (swap 'E' for 'R'), but R8-R15 are the first four Fythe registers
(e.g. R8 is FR0.o, R9 is FR0.p), and so the EDX array is offset by 

Before calling a Fythe function, you must push (This) and any Fythe registers
that are in use. Before calling a C function, you must push all processor
registers, but no Fythe registers >3.


JavaScript ABI:

Heap objects are arrays, with every other value being a primitive (object,
primitive, etc). Fythe functions take two arguments, the function itself (as an
array [object, function]) and its argument (also an array). There is no global
Fythe stack, so Fythe functions also return their result as a size-2 array.
Integers, floats, strings and functions are stored as such, objects are stored
as arrays. Tables are just standard JavaScript objects initialized to {}, with
each entry mapped to a size-2 array of the value.
