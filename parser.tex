\chapter{The Dynamic Parser Generator}\label{chap:parser}

(This section is under development)

A Fythe virtual machine has a fixed intermediate representation (Fythe IR), but
the grammar of the langauge the VM accepts is defined at runtime, and may be
changed at any time during execution. Each file is read, then parsed and
executed one statement or declaration at a time.

Fythe's parser's grammar is defined in terms of a set of parsers, each of which
may be a nonterminal, a terminal, or a negation. Nonterminals must be
explicitly defined through the \texttt{GAdd} operation, the others are defined
implicitly by their use.

Nonterminals may have any name that begins with a letter and contains no
whitespace. By convention, they are named in capitalized camel-case, with
namespaces (such as particular languages being defined within Fythe) separated
by dots. For instance, the nonterminal representing statements in a language
called \textit{A Great Language} might be called
\texttt{AGreatLanguage.Statement}.

As in any grammar, nonterminals are defined in terms of expressions, where each
element of the expression is another parser. Every nonterminal ma have any
number of these expressions. Nonterminals may be directly left recursive; that
is, the first parser in an expression defining a nonterminal may be the
nonterminal itself. They may not, however, be indirectly left recursive. Other
than that restriction, all valid context-free grammars must be supported.

Terminals in Fythe's parser are in the form of regular expressions. As such,
there is no lexical analysis. The name of a terminal must start and end with
slashes (/s), and its name is also the regular expression which it accepts.

Negations are an extension to nonterminals and terminals, and create a form of
lookahead during parsing. The name of a negation must start with an exclamation
point (!), and the remainder of the name is the parser to be negated. If the
negated parser accepts the input, then the negation rejects it. If the negated
parser rejects the input, then the negation accepts it. In either case, no
input is actually consumed by the negation.

Every parser has a target, which is Fythe value (typically Fythe IR code)
generated when the parser accepts input. Terminals generate the string their
regular expression accepted, and negations always generate Null. The value that
nonterminals generate is defined at the same time as the expression they
accept, and may be any non-circular Fythe value. When a nonterminal accepts
input, its target value is duplicated, and string literals beginning with a
dollar sign (\$) are replaced by the values generated by the subparsers of the
nonterminal. For instance, if a nonterminal \texttt{A} is defined with
expression \texttt{/a/ /b/} and target \texttt{(Object \$0)}, and accepts the
input \texttt{ab}, then it generates the value \texttt{(Object a)}.

For the purpose of documentation, nonterminals are described in this format:

\begin{verbatim}
NonTerminal = Space-separated list of parsers => Fythe value
\end{verbatim}

Because a Fythe VM expects its input to be parsed, it must also provide a
built-in grammar for the purpose of bootstrapping. The built-in grammar is:

\begin{verbatim}
White = /(([ \t\r]*(\/\*([^\*]*\*[^\/])*[^\*]*\*\/)?)*)/ => $0
WhiteN = /(([ \t\r\n]*(\/\/[^\r\n]*[\r\n])?(\/\*([^\*]*\*[^\/])*[^\*]*\*\/)?)*)/ => $0

Top = /#!.*\n/ => (Function (Null))

Top = WhiteN LanguageExpression => (Function $1)

LanguageExpression = Fythe => $0

Fythe = /fythe/ WhiteN /\{/ WhiteN Fythe.Statements /\}/ WhiteN => $4

Fythe.Statements = Fythe.Expression => $0
Fythe.Statements = Fythe.Statements Fythe.Expression => (Seq $0 $1)

Fythe.Expression = Fythe.LanguageExpression => $0
Fythe.Expression = Fythe.Object => $0
Fythe.Expression = Fythe.Literal => $0

Fythe.LanguageExpression = /\{/ WhiteN LanguageExpression /\}/ WhiteN => $2
Fythe.Object = /\(/ WhiteN Fythe.List /\)/ WhiteN => (UnliteralT $2)
Fythe.Object = /\(/ WhiteN /\)/ WhiteN => ()
Fythe.Literal = /([^\(\)\{\}@\-0-9 \t\r\n]([^\(\)\{\}\\ \t\r\n]*(\\.)*)*)/ WhiteN => $0p
Fythe.Literal = /(\/([^\\\/]*\\.)*[^\\\/]*\/)/ WhiteN => $0p
Fythe.Literal = /-?[0-9]+/ WhiteN => (SToIntegerT $0p)

Fythe.List = Fythe.Expression => (Object $0)
Fythe.List = Fythe.List Fythe.Expression => (ConcatT $0 (Object $1))
\end{verbatim}

Note that \texttt{UnliteralT}, \texttt{SToIntegerT} and \texttt{ConcatT} are
described in chapter~\ref{chap:transformer}.

The following table describes the behavior of all parser-related Fythe IR
expressions.

\LTXtable{\linewidth}{parserir.tex}
